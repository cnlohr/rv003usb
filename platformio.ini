; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

[platformio]
src_dir = .
include_dir = lib
lib_dir = doesntexist

[env]
platform = https://github.com/Community-PIO-CH32V/platform-ch32v.git
framework = ch32v003fun
; use ch32v003fun referenced in this project instead of a bleeding edge one
platform_packages = 
    framework-ch32v003fun@symlink://ch32v003fun
; only build C file here, ASM file must be built in a separate folder!
build_src_filter = +<rv003usb/rv003usb.c>
extra_scripts =
  ; convienience for adding include path of demo
  .github/add_include.py
  ; convenience for showing USB descriptors in intellisense
  pre:.github/show_descriptors.py
  ; special builder script because rv003usb.c and rv003usb.S mess up PlatformIO (same object file name)
  pre:.github/build_rv003usb.py
; for rv003usb.h to be found
build_flags = -Irv003usb

[rv003usb_base_v003]
board = genericCH32V003F4U6
; needed so that we don't get misidentified as a CH32V00{2,4,5,6} or CH32M.
build_unflags = -DCH32V00x

; All demos

[env:demo_composite_hid]
extends = rv003usb_base_v003
build_src_filter = ${env.build_src_filter} +<demo_composite_hid>

[env:demo_exti]
extends = rv003usb_base_v003
build_src_filter = ${env.build_src_filter} +<demo_exti>

[env:demo_gamepad]
extends = rv003usb_base_v003
build_src_filter = ${env.build_src_filter} +<demo_exti>

[env:demo_hidapi]
extends = rv003usb_base_v003
; we don't want to build the test programs meant for PC, only the firmware.
build_src_filter = ${env.build_src_filter} +<demo_hidapi/demo_hidapi.c>

[env:demo_pikoball_hid]
extends = rv003usb_base_v003
build_src_filter = ${env.build_src_filter} +<demo_pikoball_hid>

[env:demo_pikokey_hid]
extends = rv003usb_base_v003
build_src_filter = ${env.build_src_filter} +<demo_pikokey_hid>

[env:demo_terminal]
extends = rv003usb_base_v003
build_src_filter = ${env.build_src_filter} +<demo_terminal>

; testing programs

[env:testing_cdc_exp]
extends = rv003usb_base_v003
build_src_filter = ${env.build_src_filter} +<testing/cdc_exp>

[env:testing_demo_midi]
extends = rv003usb_base_v003
build_src_filter = ${env.build_src_filter} +<testing/demo_midi>

[env:testing_sandbox]
extends = rv003usb_base_v003
build_src_filter = ${env.build_src_filter} +<testing/sandbox>

[env:testing_ethernet]
extends = rv003usb_base_v003
build_src_filter = ${env.build_src_filter} +<testing/test_ethernet>

[env:testing_demo_xinput]
extends = rv003usb_base_v003
build_src_filter = ${env.build_src_filter} +<testing/demo_xinput>

; The bootloader is different from the regular demos

[env:bootloader]
extends = rv003usb_base_v003
; explicitly set no framework because we don't compile in ch32fun.c and have a custom linker script
framework = 
; this explicitly does not have rv003usb/rv003usb.c included, because it is provided by bootloader.c
build_src_filter = +<bootloader/bootloader.c>
board_build.ldscript = bootloader/ch32v003fun-usb-bootloader.ld
build_flags = ${env.build_flags} -DUSE_TINY_BOOT -Ich32v003fun/ch32fun

